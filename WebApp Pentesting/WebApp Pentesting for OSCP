WebApp Pentesting:(for OSCP)
=================
ssl cert:(CTF)
	we need to see ssl cert, as it may tell us emails/names/subdomains/domains
/etc/hosts:(CTF)
	sometimes, we need to put ip and domain_name to see actual site
		IP domain1 domain2
Mapping features of webapp:
	First, use webapp as normal unauthenciated user.
	Then, if there is a signup feature, ceate an account and login and visit every tab, click on every link, fill up every form.
	If it’s an e-commerce website, create an order using a fake credit card. 
	Look out for webapp features and make notes of interesting ones, example file uploads/data export/rich text editors/etc.
	Note:
		while doing it capture all the traffic with Burp.
	Note:
		It’s always tempting to switch between browser and Burp and ITS DISTRACTING.
		So, ONLY LOOK AT BROWSER DURING THIS STEP
looking in comments and discovering "Disabled Functionality":
	Comments:
		open source-code -> search "<!--"
	Disabled Functionality:(reveals either previous or future section os site)
		is it really disabled or is there anywhere to invoke it?
Directory Bruteforcing:
	Feroxbuster:
		Fastest directory bruteforcer
		feroxbuster --url http://ip.com -w wordlist.txt
		-x sh => append .sh in list (appends .sh not sh)
	Note:
		wordlist for content discovery:(dirbusting)
		seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
	Note:
		previously, i used ffuf for bruetforcing, but now, we will use feroxbuster
		there is no limit on dirbusting, we dont know which files are hidden.
		if ssh and http and linux box => try -x sh (shellshock)
		in case of IIS server, do -x aspx,asp
Fuzzing:	
	Ffuf:(github)
		fast web fuzzer written in go. it can fuzz anything
		used in dirbusting
		installation:
			sudo apt-get install ffuf
		Usage:
			ffuf -u https://site.com/FUZZ -w wordlist.txt
			ffuf -u https://site.com/FUZZ -w wordlist -recursion -e .aspx,.html => find files with a specific extension	
				flags:
					-recursion => recursive search
					-recursion-depth => to specify depth of recursion
					-e .ext1,.ext2 => to specify extensions
			Fuzzing Multiple Locations:
				ffuf -u https://W2/W1 -w ./wordlist.txt:W1,./domains.txt:W2 => basic usage
				ffuf -u https://FUZZDOMAIN/FUZZDIR -w ./wordlist.txt:FUZZDIR,./domains.txt:FUZZDOMAIN 
					ffuf will try every directory for the first domain, then every directory on the second domain. When running with many threads, this means sending 1000 requests to the same server in a very short amount of time. This often leads to getting rate-limited or banned.
				ffuf -u https://FUZZDOMAIN/FUZZDIR -w ./domains.txt:FUZZDOMAIN,./wordlist.txt:FUZZDIR 
					ffuf will try the first directory on all domains, before moving on to the next directory and trying that on all domains. This way you can send more requests without overloading the target servers.
			Bruetforcing login pages:
				Bruteforcing either username or password:
					ffuf -u https://site.com/login.php?user=la&pass=FUZZ -w wordlist.txt => get param
					ffuf -u https://site.com -X POST -d “username=admin\&password=FUZZ” -w wordlist.txt => post param
						flags:	
							-X <method> => to specify http method
							-d "request data" => to specify the data
				Bruteforcing both username and password:
					ffuf -request req.txt -request-proto http -mode clusterbomb -w usernames.txt:UFUZZ,passwords.txt:PFUZZ
						flags:
							-request req.text => specify a file with raw HTTP Request
								copy request from burp and paste it in req.text
								In the request file, UFUZZ is placed at login_username and PFUZZ is placed at login_password
							-request-proto =>
							-mode <attack_type> => to specify attack type:
								clusterbomb:
									Every word in user wordlist will be used with every word in pass wordlist
								pitchfork:
									Word at first position in user wordlist will be used with word at first position in pass wordlist.
									If the number of words in both lists are not same then the attack will stop as soon as the list with lesser number of words gets exhausted.
			other flags:
				-b "cookie" => to specify cookie data for authenciated fuzzing
				-t 50 => to specify no of threads (default => 40)
				-s => silent mode
				-c => coloured output
				-v => verbose mode
				-maxtime 60 => to end fuzzing after 60 seconds
				-timeout 5 => To set a timeout for each request in seconds (default => 10)
				Output:
				-o out.txt => ouput
				-of html => to write output in other format
					ffuf -u https://site.com/FUZZ -w wordlist.txt -of html -o ./output
					allowed formats:
						json
						ejson
						html
						md
						csv
						ecsv
				Filtering:
					To show:(To Match)
						-mc 200,302 => to specify Status code
						-ml => to specify amount of lines in response
						-mr => to specify regex pattern
						-mw => to specify amount of words in response
						-ms => to specify response size
					To not show:(To Filter out)
						-fc 200,302 => to filter Status code
						-fl => to filter amount of lines in response
						-fr => to filter regex pattern
						-fw => to filter amount of words in response
						-fs => to filter response size
In Case of CMS:(gitlab/webmin/etc)
	if we see configuration page => Misconfigured webapp 
	locate login and signup pages:
		On login page:
			try default creds
			bruteforcing using medusa/hydra/burp
			sqli
		On signup page:
			sqli
	once we become admin => upload shel
	CNS-BAsed Exploitation:	
		Magneto:
			like WP, but for 'online stores'
			magescan:(github)
				php magescan.phar scan:all http://ip
		WebDAV:
			davtest --url http://<ip> => tells about type what file types can be uploaded/executed
			ASPX shell => msfvenom
		IIS 6.0:
			ScStoragePathfromURL BOF => github g0rx
		Coldfusion 8:
			/CFIDE/administrator => logain page
			CVE-2010-2861:
				https://www.exploit-db.com/exploits/14641
				used in HTB::arctic
		Joomla: 
			joomscan -u <url> => it tells versions of joomla
			--ec => enumerate components
			important pages:
				joomla/administrator => login page for admin
				joomla/configuration.php => configuration page
			    joomla/diagnostics.php
			    joomla/joomla.inc.php
			    joomla/config.inc.php
		Wordpress:
			NOTE: In HTB, if WP is present, always add domain_name in /etc/hosts file
			wpvulnhub.com => vulnerable plugins/themes
			important pages:
				wordpress/wp-login.php => login page for admin
				wordpress/wp-admin.php => admin page
				wordpress/wp-config.php => configuration page
				wordpress/wp-json/wp/v2/users => shows users registered on wordpress
			wpscan:
				Installation:
					wpscan makes issues on kali all the time, so:
					apt remove wpscan
					gem install wpscan
				usage:
					Vulnerability Scanner for WP
					Brutefocring accounts
					Enumerating users/plugins
				wpscan --url ip => to see vulnerabilities
				wpscan --url ip --disable-tls-check => https
				wpscan --url ip --enumerate u => enumerate users
					there may be some GUEST accounts open on WP
				wpscan --url ip --wordlist xx --username user –threads 2 => for bruteforcing
				wpscan --url <ip> -eu -ap -at
				--enumerate(e)  t => theme
								p => plugins
						   		ap => all plugins
						   		vp => vulnerable plugins
								u => usernames
				--wordlist => wordlist
				--username => username	
		Drupal:
			important pages:
				<ip>/drupal/settings.php => configuartion page (we can get db_pass and db_username here)
				ip/drupal/CHANGELOG.txt => it reflects the version and last update of drupal cms
			droopescan scan drupal -u <url>
				-u => url
				--enumerate p => plugins
							t => themes
							v => version of drupal installed
							a => all
			getting reverse shell in drupal:
				log in the cms
				goto Manage>Extend>List>Install new module
				download https://www.drupal.org/project/php and install it
				then enable it
				goto Manage > Extend >filters and enable the checkbox for PHP filters
		CMSmap:(WordPress|Joomla|Drupal|Moodle)
			Installation:
				git clone https://github.com/Dionach/CMSmap
				edit cmsmap.conf:
					[exploitdb]
					edbtype = APT
					edbpath = /usr/share/exploitdb/
				pip3 install .
			Usage:	
	Note:
		always google "webapp_name source version_number" to see source files which may have left behind on webserver after installation
Testing "authenciation mechanism":(login pages)
	Bruteforcing:
		We try to test authenciation mechanism by bruteforcing users. For that we need to know valid users on a site.
		Harvesting usernames:
			Test pairs of username:password and keep an eye on:
				Different HTML response
				Different Repspnse Variable:
					logon.php?reason=0 => wrong passwordd
					logon.php?reason=1 => wrong username
				Forms may repeat a valid username on refersh
	Authenciation flow bypas:
		make an account on site and visit all urls, then logout.
		visit every url which we visited with an authenciated account
			if we are able to see it => flaw.
Testing Get parameters for available injection:
	sit.php?param=value
	always try these 3 values:
		1
		0
		-1
Testing sessionid/cookie:
	base64/hash value
	if we remove the sessionid/cookie, do the site prompt us to login again?

