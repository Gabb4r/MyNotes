WebApp Pentesting:(for OSCP)
=================
ssl cert:(CTF)
	we need to see ssl cert, as it may tell us emails/names/subdomains/domains
/etc/hosts:(CTF)
	sometimes, we need to put ip and domain_name to see actual site
		IP domain1 domain2
Mapping features of webapp:
	First, use webapp as normal unauthenciated user.
	Then, if there is a signup feature, ceate an account and login and visit every tab, click on every link, fill up every form.
	If it’s an e-commerce website, create an order using a fake credit card. 
	Look out for webapp features and make notes of interesting ones, example file uploads/data export/rich text editors/etc.
	Note:
		while doing it capture all the traffic with Burp.
	Note:
		It’s always tempting to switch between browser and Burp and ITS DISTRACTING.
		So, ONLY LOOK AT BROWSER DURING THIS STEP
looking in comments and discovering "Disabled Functionality":
	Comments:
		open source-code -> search "<!--"
	Disabled Functionality:(reveals either previous or future section os site)
		is it really disabled or is there anywhere to invoke it?
Status Codes:
	1xx => informational
	2xx => succesful request
	3xx => redirection
	4xx => request has error in it
	5xx => server encountered an issue fulfilling the request
	200 => ok
	301 => redirects the browser to a new url PERMANENTLY
	302 => redirects the browser to a new url TEMPORARILY
	304 => tells browser to use CACHED COPY of requested resource
	400 => invalid request
	401 => Authenciation required
	403 => not allowed to see the resource, even if authorized
	404 => requested resource does not exist
	500 => internal server error		
Directory Bruteforcing:
	Feroxbuster:
		Fastest directory bruteforcer
		feroxbuster --url http://ip.com -w wordlist.txt
		-x sh => append .sh in list (appends .sh not sh)
	Note:
		wordlist for content discovery:(dirbusting)
		seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
	Note:
		previously, i used ffuf for bruetforcing, but now, we will use feroxbuster
		there is no limit on dirbusting, we dont know which files are hidden.
		if ssh and http and linux box => try -x sh (shellshock)
		in case of IIS server, do -x aspx,asp
Fuzzing:	
	Ffuf:(github)
		fast web fuzzer written in go. it can fuzz anything
		used in dirbusting
		installation:
			sudo apt-get install ffuf
		Usage:
			ffuf -u https://site.com/FUZZ -w wordlist.txt
			ffuf -u https://site.com/FUZZ -w wordlist -recursion -e .aspx,.html => find files with a specific extension	
				flags:
					-recursion => recursive search
					-recursion-depth => to specify depth of recursion
					-e .ext1,.ext2 => to specify extensions
			Fuzzing Multiple Locations:
				ffuf -u https://W2/W1 -w ./wordlist.txt:W1,./domains.txt:W2 => basic usage
				ffuf -u https://FUZZDOMAIN/FUZZDIR -w ./wordlist.txt:FUZZDIR,./domains.txt:FUZZDOMAIN 
					ffuf will try every directory for the first domain, then every directory on the second domain. When running with many threads, this means sending 1000 requests to the same server in a very short amount of time. This often leads to getting rate-limited or banned.
				ffuf -u https://FUZZDOMAIN/FUZZDIR -w ./domains.txt:FUZZDOMAIN,./wordlist.txt:FUZZDIR 
					ffuf will try the first directory on all domains, before moving on to the next directory and trying that on all domains. This way you can send more requests without overloading the target servers.
			Bruetforcing login pages:
				Bruteforcing either username or password:
					ffuf -u https://site.com/login.php?user=la&pass=FUZZ -w wordlist.txt => get param
					ffuf -u https://site.com -X POST -d “username=admin\&password=FUZZ” -w wordlist.txt => post param
						flags:	
							-X <method> => to specify http method
							-d "request data" => to specify the data
				Bruteforcing both username and password:
					ffuf -request req.txt -request-proto http -mode clusterbomb -w usernames.txt:UFUZZ,passwords.txt:PFUZZ
						flags:
							-request req.text => specify a file with raw HTTP Request
								copy request from burp and paste it in req.text
								In the request file, UFUZZ is placed at login_username and PFUZZ is placed at login_password
							-request-proto =>
							-mode <attack_type> => to specify attack type:
								clusterbomb:
									Every word in user wordlist will be used with every word in pass wordlist
								pitchfork:
									Word at first position in user wordlist will be used with word at first position in pass wordlist.
									If the number of words in both lists are not same then the attack will stop as soon as the list with lesser number of words gets exhausted.
			other flags:
				-b "cookie" => to specify cookie data for authenciated fuzzing
				-t 50 => to specify no of threads (default => 40)
				-s => silent mode
				-c => coloured output
				-v => verbose mode
				-maxtime 60 => to end fuzzing after 60 seconds
				-timeout 5 => To set a timeout for each request in seconds (default => 10)
				Output:
				-o out.txt => ouput
				-of html => to write output in other format
					ffuf -u https://site.com/FUZZ -w wordlist.txt -of html -o ./output
					allowed formats:
						json
						ejson
						html
						md
						csv
						ecsv
				Filtering:
					To show:(To Match)
						-mc 200,302 => to specify Status code
						-ml => to specify amount of lines in response
						-mr => to specify regex pattern
						-mw => to specify amount of words in response
						-ms => to specify response size
					To not show:(To Filter out)
						-fc 200,302 => to filter Status code
						-fl => to filter amount of lines in response
						-fr => to filter regex pattern
						-fw => to filter amount of words in response
						-fs => to filter response size
In Case of CMS:
	if we see configuration page => Misconfigured webapp 
	locate login and signup pages:
		Directory Bruteforcing
		Gooogle "name of webapp"
	Once located login and signup pages:
		On login page:
			try default creds
			bruteforcing using medusa/hydra/burp
				Bruteforcing may result in "Account lockouts"
			sqli
		On signup page:
			sqli
	once we become admin => upload shell
	CNS-Based Exploitation:	
		Magneto:
			like WP, but for 'online stores'
			magescan:(github)
				php magescan.phar scan:all http://ip
		WebDAV:
			davtest --url http://<ip> => tells about type what file types can be uploaded/executed
			ASPX shell => msfvenom
		IIS 6.0:
			ScStoragePathfromURL BOF => github g0rx
		HFS 2.3:
			ippsec::optimum video explains the whole vulnerability.
			Its important to understand the exploitation process as sometimes exploit-db exploit fails.
		Coldfusion 8:
			/CFIDE/administrator => logain page
			CVE-2010-2861:
				https://www.exploit-db.com/exploits/14641
				used in HTB::arctic
		Tomcat:
		phpmyadmin:(an administration tool for MySQL databases)
			ip/phpmyadmin/
		gitlab:
		Joomla: 
			important pages:
				joomla/administrator => login page for admin
				joomla/configuration.php => configuration page
			    joomla/diagnostics.php
			    joomla/joomla.inc.php
			    joomla/config.inc.php
			joomscan:
				Installation:
					git clone https://github.com/OWASP/joomscan
					cd joomscan
					perl joomscan.pl
				Usage:
					joomscan -u <url> --ec => it tells versions of joomla
							--ec => enumerate components
		Wordpress:
			NOTE: In HTB, if WP is present, always add domain_name in /etc/hosts file
			wpvulnhub.com => vulnerable plugins/themes
			important pages:
				wordpress/wp-login.php => login page for admin
				wordpress/wp-admin.php => admin page
				wordpress/wp-config.php => configuration page
				wordpress/wp-json/wp/v2/users => shows users registered on wordpress
			wpscan:
				Installation:
					wpscan makes issues on kali all the time, so:
					apt remove wpscan
					gem install wpscan
				usage:
					Vulnerability Scanner for WP
					Brutefocring accounts
					Enumerating users/plugins
				wpscan --url ip => to see vulnerabilities
				wpscan --url ip --disable-tls-check => https
				wpscan --url ip --enumerate u => enumerate users
					there may be some GUEST accounts open on WP
				wpscan --url ip --wordlist xx --username user –threads 2 => for bruteforcing
				wpscan --url <ip> -eu -ap -at
				--enumerate(e)  t => theme
								p => plugins
						   		ap => all plugins
						   		vp => vulnerable plugins
								u => usernames
				--wordlist => wordlist
				--username => username	
		Drupal:
			important pages:
				/settings.php => configuartion page (we can get db_pass and db_username here)
				/CHANGELOG.txt => it reflects the version and last update of drupal cms
			Droopescan:(https://github.com/droope/droopescan.git)
				droopescan scan drupal -u <url>
					-u => url
					-e p => plugins
						t => themes
						v => version of drupal installed
						a => all
			Exploits:
				drupalgeddon:
				drupalgeddon2:
				drupalgeddon3:
			getting reverse shell in drupal:
				log in the cms
				goto Manage>Extend>List>Install new module
				download https://www.drupal.org/project/php and install it
				then enable it
				goto Manage > Extend >filters and enable the checkbox for PHP filters
		CMSmap:(WordPress|Joomla|Drupal|Moodle)
			Installation:
				git clone https://github.com/Dionach/CMSmap
				edit cmsmap.conf:
					[exploitdb]
					edbtype = APT
					edbpath = /usr/share/exploitdb/
				pip3 install .
			Usage:	
	Note:
		always google "webapp_name source version_number" to see source files which may have left behind on webserver after installation
Testing Get parameters for available injection:
	sit.php?param=value
	always try these 3 values:
		1
		0
		-1
HTTP verbs:
	Safe verbs:(read-only and dont alter the server)
		GET/HEAD/OPTIONS
	Unsafe verbs:(alters the server)
		POST/PUT/DELETE
	GET:
		x/login.php?id=1&pass=a
		no need to intercept
	HEAD:
		curl --head https://site.com
		Same as get except server response
	POST:
		x/login.php
		intercepted using burp
	PUT:
		it allows us to upload a file in some web directory:
		netcat:
			PUT /writable_folder/uploaded.html HTTP/1.1
			Host: domain.com
			Content-length: Content-length of file to upload
			<....content of file uploaded....>
	DELETE:
	CONNECT:
		tuneel within the HTTP protocol
	TRACE:
		echo the request as seen by the server
		Allows the client to see what is being recieved at other end of request chain.
		SHOULD NOT BE ENABLED in production
		finding TRACE enabled is a finding
		curl -i -H "cookie:---" X TRACE https://site.com
	PATCH:
	OPTIONS:
		helps in finding available verbs for a directory
		curl -i -X OPTIONS https://site.com
	How to find what verbs are supported?
		we can use "options", but it may be disabled by site.
		using the following bash script:(and netcat)
			#!/bin/bash
			for method in GET POST PUT TRACE CONNECT OPTIONS;
			do
				printf "$method / HTTP/1.1\r\nHost: www.site.com\r\n\r\n" | nc www.site.org 80
Curl:
	curl -i -X POST http://ip:port --data "hello"
	options:
		--head => use head verb
		-X => specify request method(always specify method in caps)
		--data "value"=> used with -X post
		-H <header> => used to supply cookie for authenciated testing
		-i => show reponse headers
	difference between CURL and WGET:
		CURL => opens a webpage in a terminal.
Encodings:
	URL Encoding:
		Capatilization doesnt matter
		\n => %0A or %0a
		\r => %0D or %0d
		%20 => encoded space
		meyerweb.com/eric/tools/dencoder/ => site for URL encoding/decoding
	HTML Encoding:
		Symbols are encoded by html to maintain security
		Double Quotes => " => &quot; or &#34;
		Single Quotes => ' => &apos; or &#39;
		Less than => < => &lt; or &#60;
		Greater than => > => &gt; or &#62;
		Note:
			&#<ASCII value of symbol>;
	Double Encoding:
Burp Suite:
	Basics:
		Target:
			sitemap:
				it has list of different websites we intercepted. Select the target_website and "add to scope"
				scope:
					where automated scanning and testing occurs
					non-scope items are not actively scanned
		Proxy:
			History:
				conatins all the last requests and their consecutive responses
		Change Request Method:
		Hot Keys:
			ctrl + shift + p => proxy
			ctrl + shift + r => Repeater
			ctrl + shift + I => intruder
			ctrl + r => send this to Repeater
			ctrl + i => send this to intruder
		change color in burp:
			user options -> display -> http message display
	Recon:
		spider:(step-1)
			it crawls the website and finds different files/forms/HTTP methods/ etc.
			Its the 1st step in a website pentest
			sitemap -> select website -> right click -> spider this host
		discover content:(step-2)
			there are some pages/folders which are not directly linked with website like /admin/
			sitemap -> select website-> right click -> egagement tools -> dicover content => this will open up the discovery module, then:
				click "session is not running": 
					it starts "smart bruteforcing":
						it means, burp learns from files and folders it find within the target and make better choices
		active scanner:(step-3)
			finds VULNERABILITIES by attacking parameters/requests
			sitemap -> select website -> right click -> actively scan this host
			NOTE:
				This is extremly loud on network. It may submit extensive queries in the application. So, its better to tell the client when we are gonna do this attack
			NOTE:
				To descrease scan times, increase the number of threads in "active can engine section"
				Be careful, as u may take down a small site, if thread count is too high
	Exploitation:
		Intruder:(automated FUZZING)
			types:	
				sniper => one payload at a time
				Battering RAM => gives same value to all payloads at same time
					USED FOR XSS
				Pitchfork => uses diff dictionary for all payloads 
				clusterbomb => same as pitchfork but every value in 1st dict is matched against every value of dict2
			FUZZING:
				parameter fuzzing:
					its different from directory bruteforcing as here we FUZZ parameters.
					items.php?id=x
					example:
						suppose a website is going to have a sale next week, its possible it has already uploaded the sale stuff, but made no links(due to which we are not able to see it), then we can use FUZZING to find sale items.
					Usage:
						XSS				
			Note:
				use seclists
		Repeater:
		sequencer:(for session token gathering)
			find a response having session tokens -> right click -> send to sequencer -> identify the session tokens to analyse -> click "Start live capture" (it will start generating session tokens)
			it tells entropy(randomness), character-level analysis, bit-level analysis
	Extender:(Bwapp store)
		install the following extensions:
			Request Highlighter
				highlights the requests
			Turbo Intruder
				faster than burp intruder
				payload place => '%s'
				start/stop turbo intruder => ctrl + enter
			logger++
				logs every reqyest and response and can filter them
			sqlipy:
				sqlmap with burp
				pg-117(thpv2)
	Reporting:
		Scanner tab -> right click on selected url -> report selected issue
Chrome DevTools:
	for a bug bounty hunter, only 4 are important:
		console:
			its used to log messages along with the name of JS file which caused the message
				its done by using these JS func's:
					console.log("message")
					console.warn("message")
					console.error("message")
				to open that JS file, double click on its name, we will go to SOURCES tab showing using the JS file along with a highlighted line which caused the log.
			used to write custom JS, can be used in XSS
				> alert()
		sources:
			shows assets/resources
			a site can have assets of other sites too such as google fonts.
			we mostly use this to view JS files.
				when we open a JS file in it, to make it look less congested, click "{}" button on bottom left (a.k.a prettyprint)
				we can also debug JS files:
					done to understand the code, a.k.a static analysis
					to add a breakpoint, click on line number of JS code and reload the site, the site will pause at that breakpoint.
				we mostly look for "API keys" in JS files
					tool: subdomainizer (see RECON)
		network:
			it shows network requests when we reload the webpage
			settings:
				enable "disable cache":
					to not get cached responses from server/browser
				disbale "show overview":
					no use
			when we double click any request, it shows us:
				header
				preview => show preview/code
				reponse => raw interpreation by server
				indicator => chain of requests
				timing
				cookies
			it also has filters:(imp)
				they help us filters requests by JS/XHR/etc.
				JS files:
					right click	on JS file -> open in sources -> see code
				XHR files:
					XML HTTP Requests
					AJAX
					fetching remote files with JS
					its used for API Calls (/api)
		application:
		elements tab:
			HTML DOM
			it also corrects any mistakes in HTML code
			differnce b/w elements tab and page source:
				page source => shows ACTUAL HTML code
				elements tab => shows CORRECTED HTML code
